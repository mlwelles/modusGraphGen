// Package generator executes code-generation templates against a parsed model
// to produce typed client libraries. It embeds all templates from the templates/
// directory and writes generated Go source files to the specified output directory.
package generator

import (
	"bytes"
	"embed"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"github.com/mlwelles/modusGraphGen/model"
)

//go:embed templates/*.tmpl
var templateFS embed.FS

// header is prepended to every generated file.
const header = "// Code generated by modusGraphGen. DO NOT EDIT.\n\n"

// Generate renders all code-generation templates against pkg and writes the
// resulting Go source files into outputDir. The directory must already exist.
func Generate(pkg *model.Package, outputDir string) error {
	// Sort entities by name for deterministic output.
	sort.Slice(pkg.Entities, func(i, j int) bool {
		return pkg.Entities[i].Name < pkg.Entities[j].Name
	})
	funcMap := template.FuncMap{
		"toLower":      strings.ToLower,
		"toUpper":      strings.ToUpper,
		"toSnakeCase":  toSnakeCase,
		"toCamelCase":  toCamelCase,
		"toLowerCamel": toLowerCamel,
		"title":        strings.Title, //nolint:staticcheck
		"hasPrefix":    strings.HasPrefix,
		"hasSuffix":    strings.HasSuffix,
		"contains":     strings.Contains,
		"trimPrefix":   strings.TrimPrefix,
		"join":         strings.Join,
		"sub":          func(a, b int) int { return a - b },
		"add":          func(a, b int) int { return a + b },

		// Field helpers for templates.
		"scalarFields":   scalarFields,
		"edgeFields":     edgeFields,
		"searchPredicate": searchPredicate,
	}

	tmpl, err := template.New("").Funcs(funcMap).ParseFS(templateFS, "templates/*.tmpl")
	if err != nil {
		return fmt.Errorf("parsing templates: %w", err)
	}

	// 1. client.go.tmpl → client_gen.go (once)
	if err := executeAndWrite(tmpl, "client.go.tmpl", pkg, filepath.Join(outputDir, "client_gen.go")); err != nil {
		return err
	}

	// 2. page_options.go.tmpl → page_options_gen.go (once)
	if err := executeAndWrite(tmpl, "page_options.go.tmpl", pkg, filepath.Join(outputDir, "page_options_gen.go")); err != nil {
		return err
	}

	// 3. iter.go.tmpl → iter_gen.go (once)
	if err := executeAndWrite(tmpl, "iter.go.tmpl", pkg, filepath.Join(outputDir, "iter_gen.go")); err != nil {
		return err
	}

	// Per-entity templates.
	type entityData struct {
		PackageName string
		Entity      model.Entity
		Entities    []model.Entity
	}

	for _, entity := range pkg.Entities {
		data := entityData{
			PackageName: pkg.Name,
			Entity:      entity,
			Entities:    pkg.Entities,
		}
		snake := toSnakeCase(entity.Name)

		// 4. entity.go.tmpl → <snake>_gen.go
		if err := executeAndWrite(tmpl, "entity.go.tmpl", data, filepath.Join(outputDir, snake+"_gen.go")); err != nil {
			return err
		}

		// 5. options.go.tmpl → <snake>_options_gen.go
		if err := executeAndWrite(tmpl, "options.go.tmpl", data, filepath.Join(outputDir, snake+"_options_gen.go")); err != nil {
			return err
		}

		// 6. query.go.tmpl → <snake>_query_gen.go
		if err := executeAndWrite(tmpl, "query.go.tmpl", data, filepath.Join(outputDir, snake+"_query_gen.go")); err != nil {
			return err
		}
	}

	// 7. cli.go.tmpl → cmd/<name>/main.go (stub)
	cliDir := filepath.Join(outputDir, "cmd", pkg.Name)
	if err := os.MkdirAll(cliDir, 0o755); err != nil {
		return fmt.Errorf("creating CLI directory: %w", err)
	}
	if err := executeAndWrite(tmpl, "cli.go.tmpl", pkg, filepath.Join(cliDir, "main.go")); err != nil {
		return err
	}

	return nil
}

// executeAndWrite renders a named template and writes the gofmt'd result to path.
func executeAndWrite(tmpl *template.Template, name string, data any, path string) error {
	var buf bytes.Buffer
	buf.WriteString(header)

	if err := tmpl.ExecuteTemplate(&buf, name, data); err != nil {
		return fmt.Errorf("executing template %s: %w", name, err)
	}

	// Format the output with gofmt.
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Write the unformatted output for debugging.
		_ = os.WriteFile(path+".broken", buf.Bytes(), 0o644)
		return fmt.Errorf("formatting %s: %w\nRaw output written to %s.broken", name, err, path)
	}

	if err := os.WriteFile(path, formatted, 0o644); err != nil {
		return fmt.Errorf("writing %s: %w", path, err)
	}

	return nil
}

// toSnakeCase converts a Go identifier like "ContentRating" to "content_rating".
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				prev := rune(s[i-1])
				if unicode.IsLower(prev) || (i+1 < len(s) && unicode.IsLower(rune(s[i+1]))) {
					result.WriteRune('_')
				}
			}
			result.WriteRune(unicode.ToLower(r))
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// toCamelCase converts a snake_case or lowercase string to CamelCase.
func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	var result strings.Builder
	for _, p := range parts {
		if len(p) > 0 {
			result.WriteString(strings.ToUpper(p[:1]))
			result.WriteString(p[1:])
		}
	}
	return result.String()
}

// toLowerCamel converts an identifier to lowerCamelCase.
func toLowerCamel(s string) string {
	if len(s) == 0 {
		return s
	}
	// If already CamelCase, just lower the first letter.
	return strings.ToLower(s[:1]) + s[1:]
}

// scalarFields returns fields that are not UID, DType, or edges.
func scalarFields(fields []model.Field) []model.Field {
	var result []model.Field
	for _, f := range fields {
		if f.IsUID || f.IsDType || f.IsEdge {
			continue
		}
		result = append(result, f)
	}
	return result
}

// edgeFields returns only edge fields.
func edgeFields(fields []model.Field) []model.Field {
	var result []model.Field
	for _, f := range fields {
		if f.IsEdge {
			result = append(result, f)
		}
	}
	return result
}

// searchPredicate returns the dgraph predicate name for the entity's search
// field, or empty string if not searchable.
func searchPredicate(entity model.Entity) string {
	if !entity.Searchable {
		return ""
	}
	for _, f := range entity.Fields {
		if f.Name == entity.SearchField {
			return f.Predicate
		}
	}
	return ""
}
